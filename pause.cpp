//=============================================================================
//
// ポーズ処理 [pause.cpp]
// Author : RIKU TANEKAWA
//
//=============================================================================

//*****************************************************************************
// インクルードファイル
//*****************************************************************************
#include "pause.h"
#include "renderer.h"
#include "manager.h"
#include "game.h"

//=============================================================================
// コンストラクタ
//=============================================================================
CPause::CPause(int nPriority) : CObject2D(nPriority)
{
	// 値のクリア
	memset(m_szPath, 0, sizeof(m_szPath));
	m_nIdxTexture	= 0;
	m_isSelected = false;
}
//=============================================================================
// デストラクタ
//=============================================================================
CPause::~CPause()
{
	// なし
}
//=============================================================================
// 生成処理
//=============================================================================
CPause* CPause::Create(MENU type,D3DXVECTOR3 pos, float fWidth, float fHeight)
{
	CPause* pPause = nullptr;

	switch (type)
	{
	case MENU_CONTINUE:
		pPause = new CContinue;
		pPause->SetPath("data/TEXTURE/continue.png");
		break;
	case MENU_RETRY:
		pPause = new CRetry;
		pPause->SetPath("data/TEXTURE/retry.png");
		break;
	case MENU_QUIT:
		pPause = new CQuit;
		pPause->SetPath("data/TEXTURE/quit.png");
		break;
	default:
		pPause = new CPause;
		break;
	}

	pPause->SetPos(pos);
	pPause->SetSize(fWidth, fHeight);
	pPause->SetCol(D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f));

	// 初期化処理
	pPause->Init();

	return pPause;
}
//=============================================================================
// 初期化処理
//=============================================================================
HRESULT CPause::Init(void)
{
	m_nIdxTexture = CManager::GetTexture()->RegisterDynamic(m_szPath);

	// 2Dオブジェクトの初期化処理
	CObject2D::Init();

	return S_OK;
}
//=============================================================================
// 終了処理
//=============================================================================
void CPause::Uninit(void)
{	
	// 2Dオブジェクトの終了処理
	CObject2D::Uninit();
}
//=============================================================================
// 更新処理
//=============================================================================
void CPause::Update(void)
{
	// 2Dオブジェクトの更新処理
	CObject2D::Update();

	// 選択項目の色の切り替え
	if (IsMouseOver() || m_isSelected)
	{
		SetCol(D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f));
	}
	else
	{
		SetCol(D3DXCOLOR(1.0f, 1.0f, 1.0f, 0.5f));
	}
}
//=============================================================================
// 描画処理
//=============================================================================
void CPause::Draw(void)
{
	// テクスチャの取得
	CTexture* pTexture = CManager::GetTexture();

	// ポーズ状態だったら
	if (CGame::GetisPaused())
	{
		// デバイスの取得
		LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

		// テクスチャの設定
		pDevice->SetTexture(0, pTexture->GetAddress(m_nIdxTexture));

		// 2Dオブジェクトの描画処理
		CObject2D::Draw();
	}
}
//=============================================================================
// マウスカーソルの判定処理
//=============================================================================
bool CPause::IsMouseOver(void)
{
	// マウスカーソルの位置を取得
	POINT cursorPos;
	GetCursorPos(&cursorPos);

	// ウィンドウハンドルを取得
	HWND hwnd = GetActiveWindow();

	// スクリーン座標をクライアント座標に変換
	ScreenToClient(hwnd, &cursorPos);

	// クライアントサイズを取得
	RECT clientRect;
	GetClientRect(hwnd, &clientRect);

	float left = GetPos().x - GetWidth();
	float right = GetPos().x + GetWidth();
	float top = GetPos().y - GetHeight();
	float bottom = GetPos().y + GetHeight();

	return (cursorPos.x >= left && cursorPos.x <= right &&
		cursorPos.y >= top && cursorPos.y <= bottom);
}


//=============================================================================
// コンティニュー項目のコンストラクタ
//=============================================================================
CContinue::CContinue()
{
	// 値のクリア

}
//=============================================================================
// コンティニュー項目のデストラクタ
//=============================================================================
CContinue::~CContinue()
{
	// なし
}
//=============================================================================
// 選択時の処理
//=============================================================================
void CContinue::Execute(void)
{
	// 続ける
	CGame::SetEnablePause(false);
}


//=============================================================================
// リトライ項目のコンストラクタ
//=============================================================================
CRetry::CRetry()
{
	// 値のクリア

}
//=============================================================================
// リトライ項目のデストラクタ
//=============================================================================
CRetry::~CRetry()
{
	// なし
}
//=============================================================================
// 選択時の処理
//=============================================================================
void CRetry::Execute(void)
{
	if (CManager::GetFade()->GetFade() != CFade::FADE_NONE)
	{
		return;
	}

	// ゲーム画面に移行
	CManager::GetFade()->SetFade(CScene::MODE_GAME);
}


//=============================================================================
// 終了項目のコンストラクタ
//=============================================================================
CQuit::CQuit()
{
	// 値のクリア

}
//=============================================================================
// 終了項目のデストラクタ
//=============================================================================
CQuit::~CQuit()
{
	// なし
}
//=============================================================================
// 選択時の処理
//=============================================================================
void CQuit::Execute(void)
{
	if (CManager::GetFade()->GetFade() != CFade::FADE_NONE)
	{
		return;
	}

	// タイトル画面に移行
	CManager::GetFade()->SetFade(CScene::MODE_TITLE);
}
